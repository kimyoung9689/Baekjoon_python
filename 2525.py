
# 오븐 시계


# 문제
# KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 
# 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 
# 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 
# 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 
# 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.

# 또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 
# 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.

# 훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 
# 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에는 현재 시각이 나온다. 
# 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 
# 정수로 빈칸을 사이에 두고 순서대로 주어진다. 
# 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다.

# 출력
# 첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. 
# (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 
# 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)

# 예제 입력 1 
# 14 30
# 20
# 예제 출력 1 
# 14 50
# 예제 입력 2 
# 17 40
# 80
# 예제 출력 2 
# 19 0
# 예제 입력 3 
# 23 48
# 25
# 예제 출력 3 
# 0 13

# 문제 요약
# 구이 시작하는 시간, 구이에 필요한 시간이 분 단위로 주어질 때
# 오븐구이가 끝나는 시간을 계산하는 프로그램 작성

# 풀이방법 1

# 사용자로부터 현재 시간,분을 먼저 입력 받기
a, b = map(int,input().split())
# 사용자로부터 요리 시간을 입력 받기
c = int(input()) 

# 현재 분 과 요리 시간을 더하기
end_minute = b + c


if end_minute >= 60:
    # 초과하는 시간 계산 (60분마다 1시간 추가)
    hours_add = end_minute // 60
    # 60분 나누고 최종 분 계산
    end_minute = end_minute % 60

    # 현재 시에 초과 시간(시) 더하기
    end_hour = a + hours_add 

else:
    # 분이 60분을 넘지 않을때 현상 유지
    end_hour = a

# 만약에 요리 끝나는 시간이 자정을 넘는다면
if end_hour >= 24:
    # 24시간의 형식 유지
    end_hour = end_hour % 24

# 요리 완성 시간 출력
print(f"요리가 완성될 시간은 {end_hour}시 {end_minute}분 입니다.")



# 풀이방법 2

# 사용자로부터 현재 시간,분을 입력 받기
a, b = map(int,input().split())
# 사용자로부터 요리 시간을 입력 받기 
c = int(input()) 

# 현재 분에 요리시간 더해주기
end_minute = b + c

# 총 시간 계산
end_hour = a + (end_minute // 60)
# 총 분 계산
end_minute = end_minute % 60

# 24시간 형식으로 변환
end_hour = end_hour % 24

# 요리 완성 시간 출력
print(end_hour, end_minute)

# print(f"요리가 완성될 시간은 {end_hour}시 {end_minute}분 입니다.")





# 풀이 후기

# 처음 풀 땐 if문으로 풀긴 했지만 조건 분기가 늘어날수록 
# 코드가 점점 길어지기에 적합한 코드가 아니라는 생각이 들었다. 
# 분이 120분 180분 이렇게 늘어날 경우 elif로 처리하거나 
# 중복 코드를 방지하려면 변수나 연산을 더해야 하는 번거로움이 커질 거 같다.

# 반면 2번째 방식은 //와 %연산자를 써 불필요한 조건문 줄이고
# 코드 길이도 많이 단축됐다.
# 시간 계산은 if문 보다 수학 연산자를 쓰는게 훨씬 효율적이라는걸
# if문으로 고생하면서 절실히 깨달았다. 앞으로 애용해야지

# 결론 : 가장 효율적이고 간결하게. 재사용 가능한 코드를 작성하는게 중요


























