
# 문제
# 이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.

# 조규현의 좌표 
# $(x_1, y_1)$와 백승환의 좌표 
# $(x_2, y_2)$가 주어지고, 조규현이 계산한 류재명과의 거리 
# $r_1$과 백승환이 계산한 류재명과의 거리 
# $r_2$가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 테스트 케이스의 개수 
# $T$가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.

# 한 줄에 공백으로 구분 된 여섯 정수 
# $x_1$, 
# $y_1$, 
# $r_1$, 
# $x_2$, 
# $y_2$, 
# $r_2$가 주어진다.

# 출력
# 각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 
# $-1$ 출력한다.

# 제한
#  
# $-10\,000 ≤ x_1, y_1, x_2, y_2 ≤ 10\,000$ 
#  
# $1 ≤ r_1, r_2 ≤ 10\,000$ 
# 예제 입력 1 
# 3
# 0 0 13 40 0 37
# 0 0 3 0 7 4
# 1 1 1 1 1 5
# 예제 출력 1 
# 2
# 1
# 0


##########################################################

#정답

import math

def solve():
    x1, y1, r1, x2, y2, r2 = map(int, input().split())

    distance = math.dist((x1, y1), (x2, y2))
    sum_r = r1 + r2
    diff_r = abs(r1 - r2)

    if distance == 0 and r1 == r2:
        print(-1)
    elif diff_r < distance < sum_r:
        print(2)
    elif distance == sum_r or distance == diff_r:
        print(1)
    else:
        print(0)

T = int(input())
for _ in range(T):
    solve()


#############################################################


# 문제 풀이 핵심: 원의 방정식과 두 원의 위치 관계


# 조규현과 백승환의 터렛은 각각 (x1,y1) , (x2,y2)
# 류재명까지의 거리 각각  r1 , r2 라는건

# 류재명의 위치 = 조규현을 중심으로 반지름이 r1인 원 위에 있을 수도 있다.
#               백승환을 중심으로 반지름이 r2인 원 위에 있을 수도 있다.


# 이 문제 = 두 원이 만나는 점의 개수를 구하는 문제


# 두 원이 만나는 경우의 수 판단하기
# 가장 중요한 건 두 원의 중심 사이의 거리(d)와 
# 두 원의 반지름(r1,r2)을 가지고 경우의 수 따져보기




# 두 터렛(원)의 중심 (x1,y1)과 (x2,y2) 사이의 거리d는 피타고라스 정리를 사용
# d=루트 (x2 - x1)제곱 + (y2 - y1)제곱
# 그리고 반지름의 합(r1 + r2)과 반지름의 차이 (|r1 - r2| or |r2 - r1|)를 비교한다.




# 경우의 수 정리 (류재명이 있을 수 있는 좌표)


# 1.두 원이 모든 점에서 만난다 (겹친다): 무한대 (-1)
# 조건: 두 원의 중심이 같고 (d=0), 반지름도 같을 때 (r1 = r2)
#두 원이 완전히 겹치기 때문에 원 위의 모든 점이 만나는 점이 된다.

# 2.두 원이 두 점에서 만난다 : 2개
# 조건:두 원의 중심이 다르고 (d>0), 반지름의 차이보다 중심 거리가 크고
# 반지름의 합보다 중심 거리가 작을때 (|r1 - r2| < d < r1 + r2)
# 두 원이 서로 겹치면서 두 지점에서 교차한다.

# 3. 두 원이 한 점에서 만난다 : 1개
# 조건:두 원의 중심이 다르고 (d>0), 반지름의 차이보다 중심 거리가 크고,
# 반지름의 합보다 중심 거리가 작을 때 (|r1 - r2| < d < r1 + r2)

# 4. 두 원이 만나지 않는다 : 0개
# 조건:두 원의 중심은 같지만(d = 0), 반지름은 다를 때(r1 != r2).(동심원이지만 크기가 달라서 안 만남)
# 두 원의 중심 거리가 반지름의 합보다 클 때 (d > r1 + r2).(너무 멀어서 안 만남)
# 한 원이 다른 원 안에 완전히 들어가 있고, 중심 거리가 반지름의 차이보다 작을 때(d < |r1 - r2|).(안쪽에 있지만 닿지 않음)

# 쉽게 말해 경우의 수 = 무한대(-1) , 2개 , 1개 , 0개



import math # 수학 계산 (여기서는 거리 계산)을 위해 math 모듈을 불러온다.

def solve():
    # 여섯 정수 x1, y1, r1, x2, y2, r2를 입력받아 각각 변수에 저장
    x1, y1, r1, x2, y2, r2 = map(int, input().split())

    # 두 원의 중심 (x1, y1)과 (x2, y2) 사이의 거리를 계산
    # math.dist((x1, y1), (x2, y2))는 두 점 사이의 유클리드 거리를 계산
    distance = math.dist((x1, y1), (x2, y2))

    # 반지름의 합을 계산
    sum_r = r1 + r2
    # 반지름의 차이를 계산 (절댓값으로)
    diff_r = abs(r1 - r2)

    # 1. 두 원의 중심이 같고, 반지름도 같은 경우 (모든 점에서 만남)
    #   즉, 두 터렛이 같은 위치에 있고, 적까지의 거리도 같으면 류재명은 무한대에 있을 수 있다.
    if distance == 0 and r1 == r2:
        print(-1) # 무한대이므로 -1 출력
    
    # 2. 두 원이 두 점에서 만나는 경우
    #   중심 거리가 반지름의 차이보다 크고, 반지름의 합보다 작을 때다.
    #   (|r1 - r2| < d < r1 + r2)
    elif diff_r < distance < sum_r:
        print(2) # 2개 지점에서 만남
    
    # 3. 두 원이 한 점에서 만나는 경우
    #   외접할 때 (d = r1 + r2) 또는 내접할 때 (d = |r1 - r2|)
    #   여기서 'distance == sum_r'은 외접, 'distance == diff_r'은 내접이다.
    elif distance == sum_r or distance == diff_r:
        # 단, 중심이 같고 반지름이 다른 경우는 만나지 않으니까 제외해야 한다.
        # (distance == 0 이고 r1 != r2 인 경우는 이미 다른 조건에서 0으로 처리될 거임)
        if distance == 0 and r1 != r2: # 이 조건은 사실 위에 'else'에 포함되긴 하지만 명시적으로 다시 체크
            print(0)
        else:
            print(1) # 1개 지점에서 만남
            
    # 4. 그 외의 경우 (두 원이 만나지 않는 경우)
    #   - 너무 멀리 떨어져 있거나 (d > r1 + r2)
    #   - 한 원이 다른 원 안에 완전히 포함되어 있을 때 (d < |r1 - r2|)
    #   - 중심은 같지만 반지름이 다른 경우 (d == 0 and r1 != r2)
    else:
        print(0) # 만나지 않으므로 0 출력

# 테스트 케이스의 개수 T를 입력받아
T = int(input())

# T번만큼 solve 함수를 반복 실행
for _ in range(T):
    solve()















